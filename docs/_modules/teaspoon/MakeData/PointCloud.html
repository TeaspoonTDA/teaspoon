<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>teaspoon.MakeData.PointCloud &mdash; teaspoon 1.3.7 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/plot_directive.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/sphinx_highlight.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: white" >
            <a href="../../../index.html" class="icon icon-home"> teaspoon
            <img src="../../../_static/teaspoon.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation/index.html">1. Getting Started</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../installation/index.html#installation">1.1. Installation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../installation/index.html#optional-dependencies">1.2. Optional Dependencies</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../installation/index.html#issues">1.3. Issues</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../modules/index.html">2. Modules</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../modules/MakeData/index.html">2.1. Make Data (MakeData) Module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/MakeData/PointCloud.html">2.1.1. Point Cloud Data Generation (PointCloud) Module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/MakeData/DynSysLib/index.html">2.1.2. Dynamical Systems Library (DynSysLib) Module</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../modules/ParamSelection/index.html">2.2. Parameter Selection Module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/ParamSelection/MI.html">2.2.1. Mutual Information</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/ParamSelection/AC.html">2.2.2. Auto-correlation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/ParamSelection/FSA.html">2.2.3. Fourier Spectrum Analysis</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/ParamSelection/PAMI.html">2.2.4. Permutation Auto Mutual Information</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/ParamSelection/MsPE.html">2.2.5. Multi-scale Permutation Entropy</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/ParamSelection/FNN.html">2.2.6. False Nearest Neighbors</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../modules/SP/index.html">2.3. Signal Processing (SP) Module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/SP/tsa.html">2.3.1. Time Series Analysis (TSA) Tools</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/SP/network.html">2.3.2. Network Representation of Time Series</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/SP/information.html">2.3.3. Information Module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/SP/misc.html">2.3.4. Miscellaneous</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/SP/texture_analysis.html">2.3.5. Texture Analysis</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/SP/stoch_bif.html">2.3.6. Stochastic P-Bifurcation Detection</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../modules/TDA/index.html">2.4. Topological Data Analaysis (TDA) Module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/TDA/PHN.html">2.4.1. Persistent Homology of Networks (PHN) Module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/TDA/distances.html">2.4.2. Distances</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/TDA/drawing.html">2.4.3. Drawing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/TDA/persistence.html">2.4.4. Persistence</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/TDA/sublevel_set_persistence.html">2.4.5. Zero Dimensional Sublevel Set Persistence (SLSP) Module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/TDA/magnitude.html">2.4.6. Magnitude</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/TDA/fast_zigzag.html">2.4.7. Fast Zigzag</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../modules/ML/index.html">2.5. Machine Learning (ML) Module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/ML/DS.html">2.5.1. Datasets</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/ML/F_PD.html">2.5.2. Featurization</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/ML/CL.html">2.5.3. Classification</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/ML/index.html#references">2.5.4. References</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../modules/DAF/index.html">2.6. Data Assimilation and Forecasting (DAF)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/DAF/Forecasting.html">2.6.1. Forecasting</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../modules/DAF/DataAssimilation.html">2.6.2. Data Assimilation</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/index.html">3. Example Notebooks</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../notebooks/distance.html">3.1. Computing Wasserstein and Bottleneck Distances</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../notebooks/persistence_images.html">3.2. Computing Features from Persistence Images</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../contributing.html">4. Contributing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../contributing.html#contributing-to-documentation">4.1. Contributing to Documentation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../license.html">5. License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../citing.html">6. Citing</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: white" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">teaspoon</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content style-external-links">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">teaspoon.MakeData.PointCloud</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for teaspoon.MakeData.PointCloud</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">scipy.spatial.distance</span> <span class="kn">import</span> <span class="n">euclidean</span>
<span class="kn">from</span> <span class="nn">ripser</span> <span class="kn">import</span> <span class="n">ripser</span>


<span class="c1">#-------------Circles and Annuli---------------------------------------#</span>
<div class="viewcode-block" id="Circle"><a class="viewcode-back" href="../../../modules/MakeData/PointCloud.html#teaspoon.MakeData.PointCloud.Circle">[docs]</a><span class="k">def</span> <span class="nf">Circle</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate :math:`N` points in :math:`\mathbb{R}^2` from the circle centered</span>
<span class="sd">    at the origin with radius :math:`r`.</span>

<span class="sd">    If `gamma` is not `None`, then we add noise</span>
<span class="sd">    using a normal distribution.  Note that this means the resulting</span>
<span class="sd">    distribution is not bounded, so your favorite stability theorem doesn&#39;t</span>
<span class="sd">    immediately apply.</span>

<span class="sd">    Parameters:</span>

<span class="sd">        N</span>
<span class="sd">            Number of points to generate</span>
<span class="sd">        r</span>
<span class="sd">            Radius of the circle</span>
<span class="sd">        gamma</span>
<span class="sd">            Standard deviation of the normally distributed noise.</span>
<span class="sd">        seed</span>
<span class="sd">            Fixes the seed.  Good if we want to replicate results.</span>

<span class="sd">    :returns:</span>
<span class="sd">        P- An :math:`N \\times 3` numpy array with a point per row.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">theta</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">N</span><span class="p">,))</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">N</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>

    <span class="n">P</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">P</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">theta</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">gamma</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># better be a number of some type!</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">P</span> <span class="o">+=</span> <span class="n">noise</span>

    <span class="k">return</span> <span class="n">P</span></div>


<div class="viewcode-block" id="Sphere"><a class="viewcode-back" href="../../../modules/MakeData/PointCloud.html#teaspoon.MakeData.PointCloud.Sphere">[docs]</a><span class="k">def</span> <span class="nf">Sphere</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">noise</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate :math:`N` points in :math:`\mathbb{R}^3` from the sphere centered</span>
<span class="sd">    at the origin with radius :math:`r`.</span>
<span class="sd">    If noise is set to a positive number, the points</span>
<span class="sd">    can be at distance :math:`r \pm` noise from the origin.</span>

<span class="sd">    Parameters:</span>

<span class="sd">        N</span>
<span class="sd">            Number of points to generate</span>
<span class="sd">        r</span>
<span class="sd">            Radius of the sphere</span>
<span class="sd">        seed</span>
<span class="sd">            Value for seed, or `None`.</span>


<span class="sd">    :returns:</span>
<span class="sd">        P- An :math:`N \\times 3` numpy array with a point per row.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>

    <span class="n">Rvect</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">noise</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">+</span> <span class="n">r</span>
    <span class="n">thetaVect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="n">phiVect</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

    <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    <span class="n">P</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">Rvect</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">thetaVect</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phiVect</span><span class="p">)</span>
    <span class="n">P</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">Rvect</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">thetaVect</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phiVect</span><span class="p">)</span>
    <span class="n">P</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">Rvect</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">thetaVect</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">P</span></div>


<div class="viewcode-block" id="Annulus"><a class="viewcode-back" href="../../../modules/MakeData/PointCloud.html#teaspoon.MakeData.PointCloud.Annulus">[docs]</a><span class="k">def</span> <span class="nf">Annulus</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Returns point cloud sampled from uniform distribution on</span>
<span class="sd">    annulus in :math:`\mathbb{R}^2` of inner radius `r` and outer radius `R`</span>

<span class="sd">    Parameters:</span>

<span class="sd">        N</span>
<span class="sd">            Number of points to generate</span>
<span class="sd">        r</span>
<span class="sd">            Inner radius of the annulus</span>
<span class="sd">        R</span>
<span class="sd">            Outer radius of the annulus</span>
<span class="sd">        seed</span>
<span class="sd">            Fixes the seed.  Good if we want to replicate results.</span>


<span class="sd">    :returns:</span>
<span class="sd">        P - An :math:`N \\times 2` numpy array with one point per row.</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="n">R</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">P</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">P</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">P</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">S</span> <span class="o">&gt;=</span> <span class="n">r</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">S</span> <span class="o">&lt;=</span> <span class="n">R</span><span class="o">**</span><span class="mi">2</span><span class="p">)]</span>
    <span class="c1"># print np.shape(P)</span>

    <span class="k">while</span> <span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">:</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="n">R</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">Q</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">Q</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="n">Q</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">S</span> <span class="o">&gt;=</span> <span class="n">r</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">S</span> <span class="o">&lt;=</span> <span class="n">R</span><span class="o">**</span><span class="mi">2</span><span class="p">)]</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="c1"># print np.shape(P)</span>

    <span class="k">return</span> <span class="n">P</span><span class="p">[:</span><span class="n">N</span><span class="p">,</span> <span class="p">:]</span></div>


<span class="c1">#-------------Torus a la Diaconis paper--------------------------------#</span>

<div class="viewcode-block" id="Torus"><a class="viewcode-back" href="../../../modules/MakeData/PointCloud.html#teaspoon.MakeData.PointCloud.Torus">[docs]</a><span class="k">def</span> <span class="nf">Torus</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>  <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Sampling method taken from Sampling from a Manifold by Diaconis,</span>
<span class="sd">    Holmes and Shahshahani, arXiv:1206.6913.</span>

<span class="sd">    Generates torus with points</span>

<span class="sd">    .. math::</span>
<span class="sd">        x = ( R + r \cos(\\theta) )  \cos(\psi),</span>
<span class="sd">    .. math::</span>
<span class="sd">        y = ( R + r\cos(\\theta) ) \sin(\psi),</span>
<span class="sd">    .. math::</span>
<span class="sd">        z = r \sin(\\theta)</span>

<span class="sd">    Need to draw :math:`\\theta` with distribution</span>

<span class="sd">    .. math::</span>
<span class="sd">        g(\\theta) = (1+ r \cos(\\theta)/R ) / (2\pi)</span>

<span class="sd">    on :math:`0 \leq \\theta &lt; 2\pi`, and :math:`\psi` with uniform density on :math:`[0,2\pi)`. Draw :math:`\\theta` uniformly from :math:`[0,2\pi)` and :math:`\eta` from :math:`[1-r/R,1+r/R]`.  If :math:`\eta&lt; 1 + (r/R) \cos(\\theta)`, return :math:`\\theta`.</span>

<span class="sd">    Parameters:</span>

<span class="sd">        N</span>
<span class="sd">            Number of points to generate</span>
<span class="sd">        r</span>
<span class="sd">            Inner radius of the torus</span>
<span class="sd">        R</span>
<span class="sd">            Outer radius of the torus</span>
<span class="sd">        seed</span>
<span class="sd">            Value for seed, or `None`.</span>

<span class="sd">    :returns:</span>
<span class="sd">        P - An :math:`N \\times 3` numpy array with one point per row.</span>

<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
    <span class="n">psi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">psi</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">psi</span>

    <span class="n">outputTheta</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">outputTheta</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">:</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">theta</span>

        <span class="n">eta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">eta</span> <span class="o">=</span> <span class="n">eta</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>

        <span class="n">fx</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">r</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">R</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>

        <span class="n">outputTheta</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[</span><span class="n">eta</span> <span class="o">&lt;</span> <span class="n">fx</span><span class="p">]</span>

    <span class="n">theta</span> <span class="o">=</span> <span class="n">outputTheta</span><span class="p">[:</span><span class="n">N</span><span class="p">]</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">theta</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">R</span> <span class="o">+</span> <span class="n">r</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">psi</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">R</span> <span class="o">+</span> <span class="n">r</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">psi</span><span class="p">)</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">N</span><span class="p">,))</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">N</span><span class="p">,))</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">N</span><span class="p">,))</span>

    <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">N</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
    <span class="n">P</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
    <span class="n">P</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span>
    <span class="n">P</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">z</span>

    <span class="k">return</span> <span class="n">P</span></div>


<span class="c1">#----------------------------------------------------------------------#</span>

<div class="viewcode-block" id="Cube"><a class="viewcode-back" href="../../../modules/MakeData/PointCloud.html#teaspoon.MakeData.PointCloud.Cube">[docs]</a><span class="k">def</span> <span class="nf">Cube</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">diam</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate `N` points in :math:`\mathbb{R}^{dim}` from the box</span>
<span class="sd">    :math:`[0,diam]\\times[0,diam]\\times ...\\times [0,diam]`</span>

<span class="sd">    Parameters:</span>

<span class="sd">        N</span>
<span class="sd">            Number of points to generate</span>
<span class="sd">        diam</span>
<span class="sd">            Points are pulled from the box :math:`[0,diam]^{dim}`</span>
<span class="sd">        dim</span>
<span class="sd">            Points are embedded in :math:`\mathbb{R}^{dim}`</span>

<span class="sd">    :returns:</span>
<span class="sd">        P - An :math:`N \\times dim` numpy array with a point per row.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>

    <span class="n">P</span> <span class="o">=</span> <span class="n">diam</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="n">dim</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">P</span></div>


<span class="c1">#----------------------------------------------------------------------#</span>

<div class="viewcode-block" id="Clusters"><a class="viewcode-back" href="../../../modules/MakeData/PointCloud.html#teaspoon.MakeData.PointCloud.Clusters">[docs]</a><span class="k">def</span> <span class="nf">Clusters</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
             <span class="n">centers</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))),</span>
             <span class="n">sd</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
             <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate `k` clusters of points in :math:`\mathbb{R}^d`, `N` points in total, approximately evenly divided.</span>
<span class="sd">    The centers are given as a :math:`k \\times d` numpy array, where `centers[i,:]` is the center of the ith cluster in :math:`\mathbb{R}^d`.</span>
<span class="sd">    Points are drawn from a normal distribution all with the same standard deviation `sd`.</span>

<span class="sd">    Parameters:</span>

<span class="sd">         N</span>
<span class="sd">            Number of points to be generated</span>
<span class="sd">         centers</span>
<span class="sd">            :math:`k \\times d` numpy array, where `centers[i,:]` is the center of</span>
<span class="sd">            the ith cluster in :math:`\mathbb{R}^d`.</span>
<span class="sd">         sd</span>
<span class="sd">            Standard deviation of clusters.</span>

<span class="sd">         seed</span>
<span class="sd">            Fixed value for the seed, or `None`.</span>

<span class="sd">    :returns:</span>

<span class="sd">        P - An :math:`N \\times d` numpy array with a point per row.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>

    <span class="c1"># Dimension for embedding</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">centers</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Identity matrix for covariance</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">sd</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

    <span class="c1"># Number of clusters</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">centers</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">ptsPerCluster</span> <span class="o">=</span> <span class="n">N</span><span class="o">//</span><span class="n">k</span>
    <span class="n">ptsForLastCluster</span> <span class="o">=</span> <span class="n">N</span><span class="o">//</span><span class="n">k</span> <span class="o">+</span> <span class="n">N</span> <span class="o">%</span> <span class="n">k</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">newPts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="p">(</span>
                <span class="n">centers</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="n">I</span><span class="p">,</span> <span class="n">ptsForLastCluster</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">newPts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="p">(</span>
                <span class="n">centers</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="n">I</span><span class="p">,</span> <span class="n">ptsPerCluster</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">P</span> <span class="o">=</span> <span class="n">newPts</span><span class="p">[:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">P</span><span class="p">,</span> <span class="n">newPts</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">P</span></div>


<span class="c1">#----------------------------------------------------------------------#</span>
<div class="viewcode-block" id="GaussianField"><a class="viewcode-back" href="../../../modules/MakeData/PointCloud.html#teaspoon.MakeData.PointCloud.GaussianField">[docs]</a><span class="k">def</span> <span class="nf">GaussianField</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Returns matrix representing the 2D gaussian field made on an m x n grid</span>

<span class="sd">    Parameters:</span>

<span class="sd">        m</span>
<span class="sd">            Integer for length of grid in x</span>
<span class="sd">        n</span>
<span class="sd">            Integer for length of grid in y</span>
<span class="sd">        a</span>
<span class="sd">            Smoothness of the gaussian field: Positive real number less than 1.0</span>
<span class="sd">        b</span>
<span class="sd">            Spatial scaling parameter: Positive real number</span>

<span class="sd">    :returns:</span>
<span class="sd">        Z</span>
<span class="sd">            A 2D numpy array</span>

<span class="sd">    &#39;&#39;&#39;</span>

    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

    <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Smoothness must be greater than 0 and &lt;= 1.&quot;</span><span class="p">)</span>
        <span class="n">exit</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Smoothness must be greater than 0 and &lt;= 1.&quot;</span><span class="p">)</span>
        <span class="n">exit</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">b</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Scaling must be positive.&quot;</span><span class="p">)</span>
        <span class="n">exit</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">cov_fun</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">a</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="o">-</span><span class="n">b</span><span class="p">))</span>

    <span class="n">tx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">ty</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">rows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
    <span class="n">cols</span> <span class="o">=</span> <span class="n">rows</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
            <span class="n">rows</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cov_fun</span><span class="p">([</span><span class="n">tx</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="n">tx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ty</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">ty</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
            <span class="n">cols</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cov_fun</span><span class="p">([</span><span class="n">tx</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="n">tx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ty</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">ty</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;diff_tx = tx[:, np.newaxis] - tx[0]</span>
<span class="sd">    diff_ty = ty[:, np.newaxis] - ty[0]</span>
<span class="sd">    cov_values = cov_fun([diff_tx, diff_ty])</span>
<span class="sd">    rows.T[:, :] = cov_values</span>
<span class="sd">    cols.T[:, :] = cov_values&quot;&quot;&quot;</span>

    <span class="n">second</span> <span class="o">=</span> <span class="n">cols</span><span class="p">[:,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">second</span> <span class="o">=</span> <span class="n">second</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">third</span> <span class="o">=</span> <span class="n">cols</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">third</span> <span class="o">=</span> <span class="n">third</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">fourth</span> <span class="o">=</span> <span class="n">rows</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">fourth</span> <span class="o">=</span> <span class="n">fourth</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">top</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">rows</span><span class="p">,</span> <span class="n">second</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">bottom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">third</span><span class="p">,</span> <span class="n">fourth</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">BlkCirc_row</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">top</span><span class="p">,</span> <span class="n">bottom</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">lam</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft2</span><span class="p">(</span><span class="n">BlkCirc_row</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">real</span> <span class="o">/</span> <span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lam</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">lam</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)])</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">lam</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">lam</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)]))</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">15</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Could not find positive definite embedding!&#39;</span><span class="p">)</span>
            <span class="n">exit</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lam</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">lam</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">lam</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">lam</span><span class="p">)</span>

    <span class="n">comp</span> <span class="o">=</span> <span class="mf">0.00000001</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                                  <span class="nb">complex</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">)))</span>

    <span class="n">F</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">lam</span><span class="p">,</span> <span class="n">comp</span><span class="p">))</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">F</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">field1</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">real</span>
    <span class="n">field2</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">imag</span>

    <span class="k">return</span> <span class="n">field1</span></div>


<span class="c1">#----------------------------------------------------------------------#</span>
<div class="viewcode-block" id="Gaussians"><a class="viewcode-back" href="../../../modules/MakeData/PointCloud.html#teaspoon.MakeData.PointCloud.Gaussians">[docs]</a><span class="k">def</span> <span class="nf">Gaussians</span><span class="p">(</span><span class="n">centers</span><span class="p">,</span> <span class="n">variances</span><span class="p">,</span> <span class="n">amplitudes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="mi">200</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Returns matrix representing the 2D gaussians made with given centers, variances and amplitudes</span>

<span class="sd">    Parameters:</span>

<span class="sd">        centers</span>
<span class="sd">            Numpy array of lists as [center x, center y] for each required peak</span>
<span class="sd">        variances</span>
<span class="sd">            Numpy array of variances for each required peak</span>
<span class="sd">        amplitudes</span>
<span class="sd">            Numpy array of amplitudes for each peak. If length is less than provided centers/variances, amplitude will be considered 1.0</span>
<span class="sd">        resolution</span>
<span class="sd">            Number of points used to generate meshgrid in both x and y</span>

<span class="sd">    :returns:</span>
<span class="sd">        Z</span>
<span class="sd">            A 2D numpy array</span>

<span class="sd">    &#39;&#39;&#39;</span>

    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">centers</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">variances</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">centers</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">variances</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Please specify all centers or reduce the supplied variances.&quot;</span><span class="p">)</span>
            <span class="n">exit</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">centers</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">variances</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Please specify all variances or reduce the supplied centers.&quot;</span><span class="p">)</span>
            <span class="n">exit</span><span class="p">()</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">centers</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="mi">5</span> <span class="o">*</span> <span class="nb">max</span><span class="p">(</span><span class="n">variances</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span>
        <span class="n">centers</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="mi">5</span> <span class="o">*</span> <span class="nb">max</span><span class="p">(</span><span class="n">variances</span><span class="p">),</span> <span class="n">resolution</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">centers</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="mi">5</span> <span class="o">*</span> <span class="nb">max</span><span class="p">(</span><span class="n">variances</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span>
        <span class="n">centers</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="mi">5</span> <span class="o">*</span> <span class="nb">max</span><span class="p">(</span><span class="n">variances</span><span class="p">),</span> <span class="n">resolution</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">amplitudes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">amplitudes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">variances</span><span class="p">))</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">amplitudes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">centers</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Please specify all centers/variances or reduce the supplied amplitudes.&quot;</span><span class="p">)</span>
        <span class="n">exit</span><span class="p">()</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">amplitudes</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">centers</span><span class="p">):</span>
        <span class="n">amplitudes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
            <span class="p">(</span><span class="n">amplitudes</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">centers</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">amplitudes</span><span class="p">))),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">center</span><span class="p">,</span> <span class="n">variance</span><span class="p">,</span> <span class="n">amplitude</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">centers</span><span class="p">,</span> <span class="n">variances</span><span class="p">,</span> <span class="n">amplitudes</span><span class="p">):</span>
        <span class="n">Z</span> <span class="o">+=</span> <span class="n">amplitude</span> <span class="o">*</span> \
            <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">((</span><span class="n">X</span> <span class="o">-</span> <span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">Y</span> <span class="o">-</span> <span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                   <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">variance</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">Z</span></div>


<span class="c1">#----------------------------------------------------------------------#</span>
<div class="viewcode-block" id="Sinc"><a class="viewcode-back" href="../../../modules/MakeData/PointCloud.html#teaspoon.MakeData.PointCloud.Sinc">[docs]</a><span class="k">def</span> <span class="nf">Sinc</span><span class="p">(</span><span class="n">x1</span><span class="o">=-</span><span class="mi">10</span><span class="p">,</span> <span class="n">x2</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">y1</span><span class="o">=-</span><span class="mi">10</span><span class="p">,</span> <span class="n">y2</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">N1</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">N2</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Returns matrix representing the 2D sinc function on grid made on x1, x2, y1, y2 of N1 and N2 length</span>

<span class="sd">    Parameters:</span>

<span class="sd">        x1</span>
<span class="sd">            Left x boundary</span>
<span class="sd">        x2</span>
<span class="sd">            Right x boundary</span>
<span class="sd">        y1</span>
<span class="sd">            Left y boundary</span>
<span class="sd">        y2</span>
<span class="sd">            Right y boundary</span>
<span class="sd">        N1</span>
<span class="sd">            Discretization of x</span>
<span class="sd">        N2</span>
<span class="sd">            Discretization of y</span>
<span class="sd">        mu </span>
<span class="sd">            Mean of normal noise added</span>
<span class="sd">        sigma</span>
<span class="sd">            Variance of normal noise added</span>


<span class="sd">    :returns:</span>
<span class="sd">        f</span>
<span class="sd">            A numpy array with shape (N1, N2)</span>

<span class="sd">    &#39;&#39;&#39;</span>

    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>

    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">N1</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
        <span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">N2</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

    <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sinc</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">))</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">f</span></div>

<span class="c1">#----------------------------------------------------------------------#</span>


<span class="c1">#----------------------------------------------------------------------#</span>


<span class="c1">#----------------------------------------------------------------------#</span>
<span class="c1">#----------------------------------------------------------------------#</span>
<span class="c1">#----------------Sets of data for ML-----------------------------------#</span>
<span class="c1">#----------------------------------------------------------------------#</span>
<span class="c1">#----------------------------------------------------------------------#</span>


<span class="c1">#----------------------------------------------------------------------#</span>
<span class="c1">#------------Normally distributed points in (birth,death) plane--------#</span>
<span class="c1">#----------------------------------------------------------------------#</span>
<div class="viewcode-block" id="normalDiagram"><a class="viewcode-back" href="../../../modules/MakeData/PointCloud.html#teaspoon.MakeData.PointCloud.normalDiagram">[docs]</a><span class="k">def</span> <span class="nf">normalDiagram</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">sd</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates a diagram with points drawn from a normal distribution in the persistence diagram plane.</span>
<span class="sd">    Pulls `N` points from a normal distribution with mean `\mu` and standard deviation `sd`, then discards any points that are below the diagonal.  Note, however, that this does not get rid of negative birth times.</span>

<span class="sd">    Parameters:</span>

<span class="sd">     N</span>
<span class="sd">        Original number of points drawn for the persistence diagram.</span>
<span class="sd">     mu, sd</span>
<span class="sd">        Mean and standard deviation of the normal distribution used to generate the points.</span>
<span class="sd">     seed</span>
<span class="sd">        Used to fix the seed if passed an integer; otherwise should be `None`.</span>

<span class="sd">    :returns:</span>
<span class="sd">        A persistence diagram given as a numpy array of size :math:`K \\times 2`.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
    <span class="n">dgm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">dgm</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">mu</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sd</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="n">dgm</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">mu</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">sd</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

    <span class="c1"># Get rid of points below the diagonal</span>
    <span class="n">good</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dgm</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">dgm</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">dgm</span> <span class="o">=</span> <span class="n">dgm</span><span class="p">[</span><span class="n">good</span><span class="p">,</span> <span class="p">:]</span>

    <span class="c1"># Get rid of points with negative birth times</span>
    <span class="n">good</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dgm</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">dgm</span> <span class="o">=</span> <span class="n">dgm</span><span class="p">[</span><span class="n">good</span><span class="p">,</span> <span class="p">:]</span>

    <span class="n">dgm</span> <span class="o">=</span> <span class="n">dgm</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>

    <span class="k">return</span> <span class="n">dgm</span></div>


<div class="viewcode-block" id="testSetClassification"><a class="viewcode-back" href="../../../modules/MakeData/PointCloud.html#teaspoon.MakeData.PointCloud.testSetClassification">[docs]</a><span class="k">def</span> <span class="nf">testSetClassification</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
                          <span class="n">numDgms</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span>
                          <span class="n">muRed</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
                          <span class="n">muBlue</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span>
                          <span class="n">sd</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                          <span class="n">permute</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                          <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Generate a collection of diagrams using the normalDiagram() function for classification tests.</span>

<span class="sd">    Parameters:</span>

<span class="sd">        N</span>
<span class="sd">            The number of initial diagrams pulled to create each diagram.  Diagrams could end up with fewer than `N` pts as the pts drawn below the diagonal will be discarded. See normalDiagram() for more information.</span>
<span class="sd">        numDgms</span>
<span class="sd">            The number of diagrams for the collection.  Can either be an integer, in which case `numDgms` is the number of diagrams of *each type* that are generated, thus returning a data set with `2*numDgms` diagrams.  Alternatively, `numDgms` can be passed as a length two list `(n,m)` where `n` diagrams of the first type and `m` diagrams of the second type are drawn, for a total of `n+m` diagrams.</span>
<span class="sd">        muRed, muBlue</span>
<span class="sd">            The means used for the normal distribution in normalDiagram() for the two different types.</span>
<span class="sd">        sd</span>
<span class="sd">            The standard deviation for the normal distribution used for normalDiagram().</span>
<span class="sd">        permute</span>
<span class="sd">            If ``permute=True``, the data frame returned has its rows randomly permuted.  If `False`, the rows will be red type followed by blue type.</span>
<span class="sd">        seed</span>
<span class="sd">            Used to fix the seed if passed an integer; otherwise should be `None`.</span>

<span class="sd">    :returns:</span>
<span class="sd">        A pandas dataframe with columns ``[&#39;Dgm&#39;, &#39;mean&#39;, &#39;sd&#39;, &#39;trainingLabel&#39;]``. In this case, the entry in `trainingLabel` is -1 if the diagram was drawn from the red type, and 1 if drawn from the blue type.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">numDgms</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">numDgms</span> <span class="o">=</span> <span class="p">(</span><span class="n">numDgms</span><span class="p">,</span> <span class="n">numDgms</span><span class="p">)</span>

    <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Dgm&#39;</span><span class="p">,</span> <span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="s1">&#39;sd&#39;</span><span class="p">,</span> <span class="s1">&#39;trainingLabel&#39;</span><span class="p">]</span>
    <span class="n">index</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">numDgms</span><span class="p">)))</span>
    <span class="n">DgmsDF</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>

    <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numDgms</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">seed</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">seed</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">dgm</span> <span class="o">=</span> <span class="n">normalDiagram</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="n">N</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">muRed</span><span class="p">,</span> <span class="n">sd</span><span class="o">=</span><span class="n">sd</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Dgm&#39;</span><span class="p">:</span> <span class="n">dgm</span><span class="p">,</span> <span class="s1">&#39;mean&#39;</span><span class="p">:</span> <span class="n">muRed</span><span class="p">,</span> <span class="s1">&#39;sd&#39;</span><span class="p">:</span> <span class="n">sd</span><span class="p">,</span> <span class="s1">&#39;trainingLabel&#39;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">}</span>
        <span class="n">DgmsDF</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">counter</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>
        <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numDgms</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">seed</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">seed</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">dgm</span> <span class="o">=</span> <span class="n">normalDiagram</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="n">N</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">muBlue</span><span class="p">,</span> <span class="n">sd</span><span class="o">=</span><span class="n">sd</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Dgm&#39;</span><span class="p">:</span> <span class="n">dgm</span><span class="p">,</span> <span class="s1">&#39;mean&#39;</span><span class="p">:</span> <span class="n">muRed</span><span class="p">,</span> <span class="s1">&#39;sd&#39;</span><span class="p">:</span> <span class="n">sd</span><span class="p">,</span> <span class="s1">&#39;trainingLabel&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>
        <span class="n">DgmsDF</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">counter</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>
        <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># Permute the data</span>
    <span class="k">if</span> <span class="n">permute</span><span class="p">:</span>
        <span class="n">DgmsDF</span> <span class="o">=</span> <span class="n">DgmsDF</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">DgmsDF</span><span class="o">.</span><span class="n">index</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">DgmsDF</span></div>


<span class="c1"># ------Experiment testing regression----------------------------</span>
<span class="c1"># ---------------LINEAR---------------------------------------</span>
<span class="c1"># -----------------------------------------------</span>

<div class="viewcode-block" id="testSetRegressionLine"><a class="viewcode-back" href="../../../modules/MakeData/PointCloud.html#teaspoon.MakeData.PointCloud.testSetRegressionLine">[docs]</a><span class="k">def</span> <span class="nf">testSetRegressionLine</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
                          <span class="n">numDgms</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span>
                          <span class="n">muStart</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
                          <span class="n">muEnd</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span>
                          <span class="n">sd</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                          <span class="n">permute</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                          <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Generate a collection of diagrams with means distributed along a line using the normalDiagram() function for regression tests.</span>

<span class="sd">    Parameters:</span>

<span class="sd">     N</span>
<span class="sd">        The number of initial points pulled to create each diagram.  Diagrams could end up with fewer than `N` pts as the pts drawn below the diagonal will be discarded. See normalDiagram() for more information.</span>
<span class="sd">     numDgms</span>
<span class="sd">        The number of diagrams for the collection given as an integer.</span>
<span class="sd">     muStart, muEnd</span>
<span class="sd">        The means used for the normal distribution in normalDiagram() are evenly spread along the line segment spanned by `muStart` and `muEnd`.</span>
<span class="sd">     sd</span>
<span class="sd">        The standard deviation for the normal distribution used for normalDiagram().</span>
<span class="sd">     permute</span>
<span class="sd">        If ``permute=True``, the data frame returned has its rows randomly permuted.  If `False`, the rows will be be sorted by the location of the means.</span>
<span class="sd">     seed</span>
<span class="sd">        Used to fix the seed if passed an integer; otherwise should be `None`.</span>

<span class="sd">    :returns:</span>
<span class="sd">        A pandas dataframe with columns ``[&#39;Dgm&#39;, &#39;mean&#39;, &#39;sd&#39;, &#39;trainingLabel&#39;]``.  In this case, `trainingLabel` is the distance from the mean used for that persistence diagram to `muStart`.</span>

<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Dgm&#39;</span><span class="p">,</span> <span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="s1">&#39;sd&#39;</span><span class="p">,</span> <span class="s1">&#39;trainingLabel&#39;</span><span class="p">]</span>
    <span class="n">index</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">numDgms</span><span class="p">)</span>
    <span class="n">DgmsDF</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">)</span>

    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="n">numDgms</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">muStart</span><span class="p">))</span><span class="o">*</span><span class="n">t</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">muEnd</span><span class="p">))</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">t</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">index</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">seed</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">seed</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">centers</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">dgm</span> <span class="o">=</span> <span class="n">normalDiagram</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="n">N</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">sd</span><span class="o">=</span><span class="n">sd</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span>
        <span class="n">distToStart</span> <span class="o">=</span> <span class="n">euclidean</span><span class="p">(</span><span class="n">muStart</span><span class="p">,</span> <span class="n">mu</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Dgm&#39;</span><span class="p">:</span> <span class="n">dgm</span><span class="p">,</span> <span class="s1">&#39;mean&#39;</span><span class="p">:</span> <span class="n">mu</span><span class="p">,</span> <span class="s1">&#39;sd&#39;</span><span class="p">:</span> <span class="n">sd</span><span class="p">,</span> <span class="s1">&#39;trainingLabel&#39;</span><span class="p">:</span> <span class="n">distToStart</span><span class="p">}</span>
        <span class="n">DgmsDF</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">counter</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>

    <span class="c1"># Permute the data</span>
    <span class="k">if</span> <span class="n">permute</span><span class="p">:</span>
        <span class="n">DgmsDF</span> <span class="o">=</span> <span class="n">DgmsDF</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">DgmsDF</span><span class="o">.</span><span class="n">index</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">DgmsDF</span></div>


<span class="c1"># ------Experiment testing regression----------------------------</span>
<span class="c1"># ---------------2D-ball around center-----------------------</span>
<span class="c1"># -----------------------------------------------</span>

<div class="viewcode-block" id="testSetRegressionBall"><a class="viewcode-back" href="../../../modules/MakeData/PointCloud.html#teaspoon.MakeData.PointCloud.testSetRegressionBall">[docs]</a><span class="k">def</span> <span class="nf">testSetRegressionBall</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
                          <span class="n">numDgms</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span>
                          <span class="n">muCenter</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
                          <span class="n">sd</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                          <span class="n">permute</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                          <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Generate a collection of diagrams with means distributed normally using the normalDiagram() function; used for regression tests.</span>

<span class="sd">    Parameters:</span>

<span class="sd">         N</span>
<span class="sd">            The number of initial diagrams pulled to create each diagram.  Diagrams could end up with fewer than `N` pts as the pts drawn below the diagonal will be discarded. See normalDiagram() for more information.</span>
<span class="sd">         numDgms</span>
<span class="sd">            The number of diagrams for the collection given as an integer.</span>
<span class="sd">         muCenter</span>
<span class="sd">            The means used for the normal distribution in normalDiagram() are drawn from the normal distribution with mean `muCenter`.</span>
<span class="sd">         sd</span>
<span class="sd">            The standard deviation for the normal distribution used for normalDiagram(), as well as for the standard deviation passed to normalDiagram().</span>
<span class="sd">         permute</span>
<span class="sd">            If ``permute=True``, the data frame returned has its rows randomly permuted.  If `False`, the rows will be be sorted by the location of the means.</span>
<span class="sd">         seed</span>
<span class="sd">            Used to fix the seed if passed an integer; otherwise should be `None`.</span>

<span class="sd">    :returns:</span>
<span class="sd">        A pandas dataframe with columns ``[&#39;Dgm&#39;, &#39;mean&#39;, &#39;sd&#39;, &#39;trainingLabel&#39;]``.  In this case, `trainingLabel` is the distance from the mean used for that persistence diagram to `muCenter`.</span>

<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Dgm&#39;</span><span class="p">,</span> <span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="s1">&#39;sd&#39;</span><span class="p">,</span> <span class="s1">&#39;trainingLabel&#39;</span><span class="p">]</span>
    <span class="n">index</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">numDgms</span><span class="p">)</span>
    <span class="n">DgmsDF</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">)</span>

    <span class="n">centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="n">muCenter</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">sd</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">numDgms</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">index</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">seed</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">seed</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">centers</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">dgm</span> <span class="o">=</span> <span class="n">normalDiagram</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="n">N</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">sd</span><span class="o">=</span><span class="n">sd</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span>
        <span class="n">distToStart</span> <span class="o">=</span> <span class="n">euclidean</span><span class="p">(</span><span class="n">muCenter</span><span class="p">,</span> <span class="n">mu</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Dgm&#39;</span><span class="p">:</span> <span class="n">dgm</span><span class="p">,</span> <span class="s1">&#39;mean&#39;</span><span class="p">:</span> <span class="n">mu</span><span class="p">,</span> <span class="s1">&#39;sd&#39;</span><span class="p">:</span> <span class="n">sd</span><span class="p">,</span> <span class="s1">&#39;trainingLabel&#39;</span><span class="p">:</span> <span class="n">distToStart</span><span class="p">}</span>
        <span class="n">DgmsDF</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">counter</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>

    <span class="c1"># Permute the data</span>
    <span class="k">if</span> <span class="n">permute</span><span class="p">:</span>
        <span class="n">DgmsDF</span> <span class="o">=</span> <span class="n">DgmsDF</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">DgmsDF</span><span class="o">.</span><span class="n">index</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">DgmsDF</span></div>


<span class="c1">#------------------------------------------------------------#</span>

<div class="viewcode-block" id="testSetManifolds"><a class="viewcode-back" href="../../../modules/MakeData/PointCloud.html#teaspoon.MakeData.PointCloud.testSetManifolds">[docs]</a><span class="k">def</span> <span class="nf">testSetManifolds</span><span class="p">(</span><span class="n">numDgms</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
                     <span class="n">numPts</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span>
                     <span class="n">permute</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                     <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span>
                     <span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Generates a collection of diagrams from different underlying topological spaces.  This set is useful for testing classification tasks.</span>

<span class="sd">    The types of underlying spaces with their entry in the `trainingLabel` column is as follows. Each function uses the default values (except for the number of points) unless otherwise noted.</span>
<span class="sd">        - **Torus**: A torus embedded in :math:`\mathbb{R}^3` using the function Torus().</span>
<span class="sd">        - **Annulus**: An annulus generated with default inputs of Annulus().</span>
<span class="sd">        - **Cube**: Points drawn uniformly from the cube :math:`[0,1]^3 \subset \mathbb{R}^3` using the function Cube().</span>
<span class="sd">        - **3Cluster**: Points are drawn using Clusters() with centers `[0,0], [0,1.5], [1.5,0]` with `sd = 0.05`.</span>
<span class="sd">        - **3Clusters of 3Clusters**: Points are drawn with 9 different centers, which can be loosely grouped into three groups of three; again uses Clusters() with `sd = 0.05`. The centers are `[0,0], [0,1.5], [1.5,0]`; this set rotated 45 degrees and shifted up by 4; and the first set shifted right 3 and up 4.</span>
<span class="sd">        - **Sphere**: Points drawn from a sphere using Sphere() with `noise = .05`.</span>

<span class="sd">    Parameters:</span>

<span class="sd">         numDgms</span>
<span class="sd">            The number of diagrams generated of each type. The resulting dataset will have `6*numDgms` diagrams.</span>
<span class="sd">         numPts</span>
<span class="sd">            The number of points in each point cloud.</span>
<span class="sd">         permute</span>
<span class="sd">            If ``permute=True``, the data frame returned has its rows randomly permuted.  If `False`, the rows will be red type followed by blue type.</span>
<span class="sd">         seed</span>
<span class="sd">            Used to fix the seed if passed an integer; otherwise should be `None`.</span>

<span class="sd">    :returns:</span>
<span class="sd">        A pandas DataFrame with columns ``[&#39;Dgm0&#39;, &#39;Dgm1&#39;, &#39;trainingLabel&#39;]``.  The `trainingLabel` row has entries with labels given as the boldface above.</span>

<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Dgm0&#39;</span><span class="p">,</span> <span class="s1">&#39;Dgm1&#39;</span><span class="p">,</span> <span class="s1">&#39;trainingLabel&#39;</span><span class="p">]</span>
    <span class="n">index</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="o">*</span><span class="n">numDgms</span><span class="p">)</span>
    <span class="n">DgmsDF</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">)</span>

    <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">fixSeed</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fixSeed</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># -</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Generating torus clouds...&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numDgms</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">fixSeed</span><span class="p">:</span>
            <span class="n">seed</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">dgmOut</span> <span class="o">=</span> <span class="n">ripser</span><span class="p">(</span><span class="n">Torus</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="n">numPts</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">))[</span>
            <span class="s1">&#39;dgms&#39;</span><span class="p">]</span>  <span class="c1"># using ripser package</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Dgm0&#39;</span><span class="p">:</span> <span class="n">dgmOut</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;Dgm1&#39;</span><span class="p">:</span> <span class="n">dgmOut</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;trainingLabel&#39;</span><span class="p">:</span> <span class="s1">&#39;Torus&#39;</span><span class="p">}</span>
        <span class="n">DgmsDF</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">counter</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>
        <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># -</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Generating annuli clouds...&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numDgms</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">fixSeed</span><span class="p">:</span>
            <span class="n">seed</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">dgmOut</span> <span class="o">=</span> <span class="n">ripser</span><span class="p">(</span><span class="n">Annulus</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="n">numPts</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">))[</span><span class="s1">&#39;dgms&#39;</span><span class="p">]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Dgm0&#39;</span><span class="p">:</span> <span class="n">dgmOut</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;Dgm1&#39;</span><span class="p">:</span> <span class="n">dgmOut</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                <span class="s1">&#39;trainingLabel&#39;</span><span class="p">:</span> <span class="s1">&#39;Annulus&#39;</span><span class="p">}</span>
        <span class="n">DgmsDF</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">counter</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>
        <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># -</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Generating cube clouds...&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numDgms</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">fixSeed</span><span class="p">:</span>
            <span class="n">seed</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">dgmOut</span> <span class="o">=</span> <span class="n">ripser</span><span class="p">(</span><span class="n">Cube</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="n">numPts</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">))[</span><span class="s1">&#39;dgms&#39;</span><span class="p">]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Dgm0&#39;</span><span class="p">:</span> <span class="n">dgmOut</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;Dgm1&#39;</span><span class="p">:</span> <span class="n">dgmOut</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;trainingLabel&#39;</span><span class="p">:</span> <span class="s1">&#39;Cube&#39;</span><span class="p">}</span>
        <span class="n">DgmsDF</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">counter</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>
        <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># -</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Generating three cluster clouds...&#39;</span><span class="p">)</span>
    <span class="c1"># Centered at (0,0), (0,5), and (5,0) with sd =1</span>
    <span class="c1"># Then scaled by .3 to make birth/death times closer to the other examples</span>
    <span class="n">centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
    <span class="c1"># centers = np.array( [ [0,0], [0,2], [2,0]  ])</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numDgms</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">fixSeed</span><span class="p">:</span>
            <span class="n">seed</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">dgmOut</span> <span class="o">=</span> <span class="n">ripser</span><span class="p">(</span><span class="n">Clusters</span><span class="p">(</span><span class="n">centers</span><span class="o">=</span><span class="n">centers</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="n">numPts</span><span class="p">,</span>
                                 <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span> <span class="n">sd</span><span class="o">=</span><span class="mf">.05</span><span class="p">))[</span><span class="s1">&#39;dgms&#39;</span><span class="p">]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Dgm0&#39;</span><span class="p">:</span> <span class="n">dgmOut</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;Dgm1&#39;</span><span class="p">:</span> <span class="n">dgmOut</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                <span class="s1">&#39;trainingLabel&#39;</span><span class="p">:</span> <span class="s1">&#39;3Cluster&#39;</span><span class="p">}</span>
        <span class="n">DgmsDF</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">counter</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>
        <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># -</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Generating three clusters of three clusters clouds...&#39;</span><span class="p">)</span>

    <span class="n">centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span>
    <span class="n">centersUp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">centers</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)),</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">))]))</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
    <span class="n">centersUpRight</span> <span class="o">=</span> <span class="n">centers</span> <span class="o">+</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
    <span class="n">centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">centers</span><span class="p">,</span>  <span class="n">centersUp</span><span class="p">,</span> <span class="n">centersUpRight</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numDgms</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">fixSeed</span><span class="p">:</span>
            <span class="n">seed</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">dgmOut</span> <span class="o">=</span> <span class="n">ripser</span><span class="p">(</span><span class="n">Clusters</span><span class="p">(</span><span class="n">centers</span><span class="o">=</span><span class="n">centers</span><span class="p">,</span>
                                 <span class="n">N</span><span class="o">=</span><span class="n">numPts</span><span class="p">,</span>
                                 <span class="n">sd</span><span class="o">=</span><span class="mf">.05</span><span class="p">,</span>
                                 <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">))[</span><span class="s1">&#39;dgms&#39;</span><span class="p">]</span>
        <span class="c1"># Dgms.append([dgmOut[0],dgmOut[1]])</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Dgm0&#39;</span><span class="p">:</span> <span class="n">dgmOut</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;Dgm1&#39;</span><span class="p">:</span> <span class="n">dgmOut</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                <span class="s1">&#39;trainingLabel&#39;</span><span class="p">:</span> <span class="s1">&#39;3Clusters of 3Clusters&#39;</span><span class="p">}</span>
        <span class="n">DgmsDF</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">counter</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>
        <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># -</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Generating sphere clouds...&#39;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numDgms</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">fixSeed</span><span class="p">:</span>
            <span class="n">seed</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">dgmOut</span> <span class="o">=</span> <span class="n">ripser</span><span class="p">(</span><span class="n">Sphere</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="n">numPts</span><span class="p">,</span> <span class="n">noise</span><span class="o">=</span><span class="mf">.05</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">))[</span><span class="s1">&#39;dgms&#39;</span><span class="p">]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Dgm0&#39;</span><span class="p">:</span> <span class="n">dgmOut</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;Dgm1&#39;</span><span class="p">:</span> <span class="n">dgmOut</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                <span class="s1">&#39;trainingLabel&#39;</span><span class="p">:</span> <span class="s1">&#39;Sphere&#39;</span><span class="p">}</span>
        <span class="n">DgmsDF</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">counter</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>
        <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Finished generating clouds and computing persistence.</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="c1"># Permute the diagrams if necessary.</span>
    <span class="k">if</span> <span class="n">permute</span><span class="p">:</span>
        <span class="n">DgmsDF</span> <span class="o">=</span> <span class="n">DgmsDF</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">DgmsDF</span><span class="o">.</span><span class="n">index</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">DgmsDF</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Munch and Khasawneh.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
    <!-- Theme Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-XXXXXXX-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-XXXXXXX-1', {
          'anonymize_ip': false,
      });
    </script> 

</body>
</html>